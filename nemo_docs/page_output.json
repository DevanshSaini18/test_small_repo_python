[
  {
    "text": "# Core Data Models (Domain Layer)\n\nSource of truth for the application's data model and multi-tenant domain logic. app/models.py defines the SQLAlchemy ORM layer that represents organizations, users, teams, items (tasks), tags, comments, attachments, activity logs, API keys, webhooks, and usage logs.\n\nKey points:\n- Multi-tenancy: Organization is the top-level tenant; most entities carry organization_id and relationships are constrained with ondelete cascades so tenant deletion removes related data.\n- Enums used to capture domain states: PriorityLevel (low/medium/high/urgent), ItemStatus (todo, in_progress, in_review, done, archived), UserRole (owner/admin/member/viewer), SubscriptionTier (free/starter/professional/enterprise).\n- Associations: Many-to-many relationships are explicit via association tables user_teams, item_tags, item_assignees to model teams, tags, and assignees.\n- Items: Rich task model with parent/child self-referential relationship for subtasks, assignees, tags, attachments, timestamps (created_at/updated_at/completed_at), estimated/actual hours and priority/status fields.\n- Activity and usage: ActivityLog tracks user actions (created/updated/deleted/commented) with JSON details; UsageLog captures request-level metrics by organization for analytics.\n- API keys & Webhooks: APIKey model stores sk_-style keys with expiry and last_used, Webhook stores endpoint, events, secret for signature verification.\n- Constraints & cascade behaviour: ForeignKeys use ondelete CASCADE/SET NULL aligned with expected semantics (e.g., deleting a user or organization cleans up related items or sets created_by to null where appropriate).\n\nWhy it matters:\nThis file encapsulates the domain shape and database constraints that the rest of the app (services, routes, analytics) rely on. Any change here impacts migrations, queries, and RBAC/enforcement logic.\n",
    "source_files": [
      "app/models.py"
    ]
  },
  {
    "text": "# Service Layer (Business Logic & Data Access)\n\napp/services.py implements transactional, database-backed operations and higher-level business rules on top of the ORM models. It centralizes CRUD operations, activity/usage logging, analytics, and composite behaviors used by API handlers.\n\nResponsibilities & patterns:\n- CRUD and list operations for Organization, User, Team, Item, Comment, Tag, APIKey, Webhook, and Activity/Usage logs.\n- Transactional flow: create -> flush/extend relationships -> commit -> refresh; services take a Session and use domain models rather than raw SQL.\n- Activity logging: log_activity is called by create/update/delete paths to record changes (details often JSON-encoded) for audit and UI feed functionality.\n- Complex updates: update_item handles differential updates for assignees/tags (replacing associations), tracks field changes for activity logs, and sets completed_at when status flips to DONE.\n- Analytics: get_item_analytics and get_usage_analytics aggregate counts (by status, priority), overdue/completed metrics, average completion time and usage statistics (request counts, endpoints, average response time, error rate).\n- API key & webhook creation: generate_api_key is used to produce secure keys and webhooks persist secrets for signature verification.\n- Item listing relies on status, priority, and assignee filters, with pagination controls for skip/limit.\n\nOperational notes:\n- Services assume proper authorization and org-scoped checks are enforced by higher-level dependencies/routes.\n- Most functions return ORM instances (refreshed) for direct response serialization via Pydantic's orm_mode.\n- Performance: queries use SQLAlchemy aggregates; larger datasets/pagination may need explicit indexing and optimized queries (see Data & Infra pages).\n",
    "source_files": [
      "app/services.py",
      "app/models.py",
      "app/auth.py",
      "app/schemas.py"
    ]
  },
  {
    "text": "# API Layer & Routing (HTTP Surface)\n\napp/routes.py (mounted at /api/v1 in main.py) exposes the HTTP REST surface and maps incoming requests to service layer operations. main.py wires the router in and configures application-level middleware (CORS, logging, exception handling).\n\nMajor endpoint groups:\n- Authentication: POST /auth/register, POST /auth/login, GET /auth/me \u2014 user registration, token issuance (JWT), and user info.\n- Organizations: POST /organizations, GET /organizations/current, GET /organizations/{org_id}/users \u2014 create and read tenant info and membership lists.\n- Teams: POST /teams, POST /teams/{team_id}/members/{user_id} \u2014 team creation and membership management (Admin only via dependency).\n- Items (tasks): POST /items, GET /items/{item_id}, GET /items (filters: team_id/status/priority/assigned_to/skip/limit), PUT /items/{item_id}, DELETE /items/{item_id} \u2014 core task lifecycle, with text-based search removed from the service layer, leaving the remaining filters to map to SQLAlchemy queries.\n- Comments: POST /comments, GET /items/{item_id}/comments \u2014 commenting on items.\n- Tags: POST /tags, GET /tags \u2014 tagging support.\n- Notifications: POST /notifications/due-reminders, POST /notifications/overdue \u2014 admin-triggered reminder and overdue alert dispatch via notification_service.\n- Exports: GET /export/items/csv, GET /export/items/json, GET /export/activity-log/csv \u2014 export endpoints that stream CSV/JSON attachments using fastapi.responses.Response and export_service, honoring organization scope, filters (team/status/priority), include_comments flag, and admin-only limits on activity logs.\n- Reports: GET /reports/team/{team_id}, GET /reports/user/{user_id}, GET /reports/organization \u2014 report generation APIs backed by export_service, with user-level safeguards (users can only view their own report unless admin) and admin-only organization summaries.\n- API Keys & Webhooks: Admin-only endpoints for managing API keys (/api-keys) and webhooks (/webhooks).\n- Activity & Analytics: GET /activity, GET /analytics/items, GET /analytics/usage \u2014 auditing and operational analytics.\n\nImportant behaviors:\n- Response models: Endpoints return Pydantic schemas (app/schemas.py) for consistent request/response shapes and validation, while export/download endpoints return streaming Response objects with appropriate content-disposition headers.\n- Auth & RBAC: Endpoints declare dependencies to enforce JWT-based authentication and role checks (require_role) or API key verification, including new admin-only report/export/notification routes and user-scoped report access.\n- Pagination & filtering: list endpoints support skip/limit and the supported typed filters that map to SQLAlchemy queries in services (team/status/priority/assigned_to only, without the prior title/description text search).\n- Status codes: create operations use 201, deletes use 204, and routes raise HTTPException with appropriate codes on not-found/forbidden/unauthorized.\n\nmain.py highlights:\n- Mounts router at /api/v1, creates DB tables at startup (Base.metadata.create_all), and configures middleware:\n  - CORS (allow_origins=[\"*\"] by default; production should restrict origins)\n  - Request timing middleware that adds X-Process-Time header and logs request method/path/status/time\n  - Global exception handler returning 500 with structured logging",
    "source_files": [
      "app/routes.py",
      "main.py",
      "app/services.py",
      "app/schemas.py",
      "app/dependencies.py"
    ]
  },
  {
    "text": "# Export Service (Reports & Data Exports)\n\napp/export.py defines ExportService, which produces CSV/JSON exports and summary reports consumed by the export and report endpoints described above. The service uses get_items/get_item_analytics to pull org-scoped item data (with skip=0 and limit=10000 safeguards) and serializes related assignees, tags, created_by, and optional comments via the csv and json stdlib helpers.\n\nCapabilities include:\n- export_items_to_csv: writes item metadata (status, priority, timestamps, estimates) to a StringIO-backed CSV with flattened assignee/tag lists, suitable for streaming responses.\n- export_items_to_json: builds rich JSON payloads with nested assignees, tags, created_by info, and optional comments, along with export_date and organization metadata.\n- generate_team_report / generate_user_report: compute statistics (completion rates, status/priority breakdowns, overdue counts, member workload, recent activity) for teams and users by querying Team, Item, User, ActivityLog, and aggregating using defaultdict-based counters.\n\nWhy it matters:\nThis isolated export service keeps serialization concerns out of the route handlers while ensuring the exported artifact mirrors the core domain model and logged analytics. Reports incorporate calculated insights, so clients have a single place to adjust summaries without touching endpoints.",
    "source_files": [
      "app/export.py"
    ]
  },
  {
    "text": "# Notification Service (Email Alerts & Reminders)\n\napp/notifications.py provides NotificationService, which currently logs email delivery flows for item assignments, comments, status changes, and due-date reminders in place of a fully configured SMTP client.\n\nCapabilities include:\n- send_email: composes multipart plain/text+HTML MIME messages, logs deliveries, and is prepared to use SMTP hosts (default smtp.gmail.com) once enabled.\n- notify_item_assigned / notify_comment_added / notify_status_changed: iterate assignees (excluding the commenter where appropriate) and send templated notifications detailing titles, descriptions, priority, status, and due dates; each returns per-recipient success statuses.\n- send_due_date_reminders: finds items due on a target date (days_before) with non-DONE status, notifies each assignee with a reminder template, and returns aggregated statistics (total_items, notifications sent, successes).\n\nWhy it matters:\nCentralizing notification templates and delivery tracking keeps the reminder and alert endpoints lean, while the same service can later be extended with real SMTP credentials, queueing, or integration with third-party email providers.",
    "source_files": [
      "app/notifications.py"
    ]
  },
  {
    "text": "# Authentication & Authorization\n\nSecurity primitives are implemented across app/auth.py and app/dependencies.py to support password-based login, JWT access tokens, API keys, and role-based authorization.\n\nAuth primitives (app/auth.py):\n- Password hashing & verification: passlib CryptContext with bcrypt scheme (get_password_hash, verify_password).\n- JWT tokens: create_access_token and decode_access_token using python-jose with HS256. SECRET_KEY is generated in code for dev (secrets.token_urlsafe) \u2014 production must source this from a secure environment variable.\n- API key generation: generate_api_key produces sk_-prefixed secrets using secrets.token_urlsafe.\n\nDependency layer (app/dependencies.py):\n- HTTPBearer-based token reading: get_current_user decodes JWT, fetches user by id (payload[\"sub\"]), ensures active user, updates last_login timestamp.\n- get_current_active_user / get_current_organization: thin wrappers that enforce active user and active tenant checks.\n- require_role(required_role): factory that enforces role hierarchy (viewer < member < admin < owner) for Admin/Owner-only endpoints.\n- verify_api_key: header-based X-API-KEY check that looks up active APIKey, checks expiration, updates last_used_at and returns organization context.\n\nSecurity notes:\n- Token expiry is set to 24 hours in code (ACCESS_TOKEN_EXPIRE_MINUTES constant) but is configurable if replaced by env-based settings.\n- Secrets in the code are placeholders; immediate change is required before production (use .env and secrets manager).\n- RBAC is enforced at route-level through dependencies rather than inline checks; this yields composable, testable authorization logic.\n",
    "source_files": [
      "app/auth.py",
      "app/dependencies.py",
      "app/models.py"
    ]
  },
  {
    "text": "# Application Entrypoint, Middleware & Observability\n\nmain.py is the FastAPI application bootstrap that configures middleware, logging, global exception handling, DB creation and mounts the API router.\n\nMiddleware & behaviors:\n- CORS: CORSMiddleware is configured with allow_origins=[\"*\"] (placeholder) \u2014 update to explicit origins in production.\n- Request timing: a custom middleware wraps each request to record processing time (ms), logs method/path/status/time and injects X-Process-Time header into responses.\n- Global exception handler: catches unhandled exceptions, logs stack traces, and returns a 500 JSON response.\n- Auto schema/docs: FastAPI docs available at /docs and /redoc per app config.\n- Item listing now relies solely on the various status/priority/assignee filters; the optional search_text query parameter and corresponding case-insensitive title/description filtering have been removed.\n- Notification, export, and report routes are now registered via the main router, using notification_service for due-date reminders/overdue alerts and export_service for CSV/JSON item exports, activity logs, and team/user/organization reports, with exports streamed as attachment responses and role checks applied where required.\n\nOperational observability & logging:\n- Uses Python logging with INFO level; request middleware logs each request. Services and handlers also raise HTTPException with clear status codes which surface to clients.\n- The code contains TODOs to persist request-level metrics to the DB (log_usage) where the org_id extraction would be required from the auth token.\n\nStartup behavior:\n- Calls Base.metadata.create_all(bind=engine) to ensure DB tables exist at service start.\n- Includes root and /health endpoints for basic readiness/liveness checks.",
    "source_files": [
      "main.py",
      "app/routes.py",
      "app/services.py"
    ]
  },
  {
    "text": "# Database Engine, Sessions & Lifecycle\n\napp/database.py provides the SQLAlchemy engine, SessionLocal factory, and Base declarative class used across the application.\n\nContents & usage:\n- Engine: create_engine configured for SQLite by default (sqlite:///./test.db) with connect_args={\"check_same_thread\": False} to allow multi-threaded access in dev server. Production should replace this URL with a managed RDBMS (Postgres) and use connection pooling settings.\n- SessionLocal: sessionmaker(autocommit=False, autoflush=False, bind=engine) returning scoped Session instances used by get_db dependency.\n- Base: declarative_base used by app/models.py for ORM class definitions.\n- get_db dependency: yields a session per request and ensures closure in a finally block \u2014 used widely in route dependencies and services.\n\nOperational notes & gaps:\n- No migrations: The project calls Base.metadata.create_all(bind=engine) in main.py to create tables at startup \u2014 fine for early development but migrations (Alembic) are required for production schema evolution.\n- Indexes: models define index=True on common lookups but larger scale requires explicit index planning and query profiling.\n- Backups & restore: not implemented inside code; docs/deployment.md references backup strategies. For production, point DB to external service and backup snapshots.\n",
    "source_files": [
      "app/database.py",
      "app/models.py",
      "main.py",
      "docs/deployment.md"
    ]
  },
  {
    "text": "# Application Entrypoint, Middleware & Observability\n\nmain.py is the FastAPI application bootstrap that configures middleware, logging, global exception handling, DB creation and mounts the API router.\n\nMiddleware & behaviors:\n- CORS: CORSMiddleware is configured with allow_origins=[\"*\"] (placeholder) \u2014 update to explicit origins in production.\n- Request timing: a custom middleware wraps each request to record processing time (ms), logs method/path/status/time and injects X-Process-Time header into responses.\n- Global exception handler: catches unhandled exceptions, logs stack traces, and returns a 500 JSON response.\n- Auto schema/docs: FastAPI docs available at /docs and /redoc per app config.\n- Item listing now relies solely on the various status/priority/assignee filters; the optional search_text query parameter and corresponding case-insensitive title/description filtering have been removed.\n- Notification, export, and report routes are now registered via the main router, using notification_service for due-date reminders/overdue alerts and export_service for CSV/JSON item exports, activity logs, and team/user/organization reports, with exports streamed as attachment responses and role checks applied where required.\n\nOperational observability & logging:\n- Uses Python logging with INFO level; request middleware logs each request. Services and handlers also raise HTTPException with clear status codes which surface to clients.\n- The code contains TODOs to persist request-level metrics to the DB (log_usage) where the org_id extraction would be required from the auth token.\n\nStartup behavior:\n- Calls Base.metadata.create_all(bind=engine) to ensure DB tables exist at service start.\n- Includes root and /health endpoints for basic readiness/liveness checks.\n",
    "source_files": [
      "main.py",
      "app/routes.py",
      "app/services.py"
    ]
  },
  {
    "text": "# Infrastructure & Deployment Notes\n\nThe repository contains Docker and deployment artifacts and supporting docs to run the application in development and production.\n\nKey files & responsibilities:\n- docker-compose.yml: orchestration for PostgreSQL (production or dev), application, and Nginx reverse proxy. Configures volumes, health checks, environment variables, ports, and restart policies.\n- Dockerfile: builds a Python 3.11-slim based image (installs system deps, Python deps, copies source, runs uvicorn). Use for containerized deployment.\n- .env.example: template for environment variables (DB URL, SECRET_KEY, CORS, rate limiting, upload paths, logging). Important to fill for production and not keep secrets in source.\n- docs/deployment.md & docs/feature-comparison.md: provide production deployment guidance \u2014 SSL termination, scaling notes, monitoring, backups, migrations, and security hardening recommendations.\n\nProduction considerations:\n- Replace SQLite with managed Postgres & add Alembic migrations (no migrations implemented currently).\n- Move SECRET_KEY and other secrets to environment / secret manager; do not use runtime-generated secrets in production.\n- Configure CORS, rate limits, and RBAC defaults appropriately; enable request/usage logging into UsageLog for billing/analytics.\n- Add CI pipeline to build images, run tests, run migrations, and push artifacts. Add monitoring/alerting (Prometheus/Grafana, centralized logs) per docs.\n",
    "source_files": [
      "docker-compose.yml",
      "Dockerfile",
      ".env.example",
      "docs/deployment.md",
      "README.md"
    ]
  }
]