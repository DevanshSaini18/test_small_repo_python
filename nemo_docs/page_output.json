[
  {
    "text": "# Core Data Models (Domain Layer)\n\nSource of truth for the application's data model and multi-tenant domain logic. app/models.py defines the SQLAlchemy ORM layer that represents organizations, users, teams, items (tasks), tags, comments, attachments, activity logs, API keys, webhooks, and usage logs.\n\nKey points:\n- Multi-tenancy: Organization is the top-level tenant; most entities carry organization_id and relationships are constrained with ondelete cascades so tenant deletion removes related data.\n- Enums used to capture domain states: PriorityLevel (low/medium/high/urgent), ItemStatus (todo, in_progress, in_review, done, archived), UserRole (owner/admin/member/viewer), SubscriptionTier (free/starter/professional/enterprise).\n- Associations: Many-to-many relationships are explicit via association tables user_teams, item_tags, item_assignees to model teams, tags, and assignees.\n- Items: Rich task model with parent/child self-referential relationship for subtasks, assignees, tags, attachments, timestamps (created_at/updated_at/completed_at), estimated/actual hours and priority/status fields.\n- Activity and usage: ActivityLog tracks user actions (created/updated/deleted/commented) with JSON details; UsageLog captures request-level metrics by organization for analytics.\n- API keys & Webhooks: APIKey model stores sk_-style keys with expiry and last_used, Webhook stores endpoint, events, secret for signature verification.\n- Constraints & cascade behaviour: ForeignKeys use ondelete CASCADE/SET NULL aligned with expected semantics (e.g., deleting a user or organization cleans up related items or sets created_by to null where appropriate).\n\nWhy it matters:\nThis file encapsulates the domain shape and database constraints that the rest of the app (services, routes, analytics) rely on. Any change here impacts migrations, queries, and RBAC/enforcement logic.\n",
    "source_files": [
      "app/models.py"
    ]
  },
  {
    "text": "# Service Layer (Business Logic & Data Access)\n\napp/services.py implements transactional, database-backed operations and higher-level business rules on top of the ORM models. It centralizes CRUD operations, activity/usage logging, analytics, and composite behaviors used by API handlers.\n\nResponsibilities & patterns:\n- CRUD and list operations for Organization, User, Team, Item, Comment, Tag, APIKey, Webhook, and Activity/Usage logs.\n- Transactional flow: create -> flush/extend relationships -> commit -> refresh; services take a Session and use domain models rather than raw SQL.\n- Activity logging: log_activity is called by create/update/delete paths to record changes (details often JSON-encoded) for audit and UI feed functionality.\n- Complex updates: update_item handles differential updates for assignees/tags (replacing associations), tracks field changes for activity logs, and sets completed_at when status flips to DONE.\n- Analytics: get_item_analytics and get_usage_analytics aggregate counts (by status, priority), overdue/completed metrics, average completion time and usage statistics (request counts, endpoints, average response time, error rate).\n- API key & webhook creation: generate_api_key is used to produce secure keys and webhooks persist secrets for signature verification.\n- Item listing relies on status, priority, and assignee filters, with pagination controls for skip/limit.\n\nOperational notes:\n- Services assume proper authorization and org-scoped checks are enforced by higher-level dependencies/routes.\n- Most functions return ORM instances (refreshed) for direct response serialization via Pydantic's orm_mode.\n- Performance: queries use SQLAlchemy aggregates; larger datasets/pagination may need explicit indexing and optimized queries (see Data & Infra pages).\n",
    "source_files": [
      "app/services.py",
      "app/models.py",
      "app/auth.py",
      "app/schemas.py"
    ]
  },
  {
    "text": "# API Layer & Routing (HTTP Surface)\n\napp/routes.py (mounted at /api/v1 in main.py) exposes the HTTP REST surface and maps incoming requests to service layer operations. main.py wires the router in and configures application-level middleware (CORS, logging, exception handling).\n\nMajor endpoint groups:\n- Authentication: POST /auth/register, POST /auth/login, GET /auth/me \u2014 user registration, token issuance (JWT), and user info.\n- Organizations: POST /organizations, GET /organizations/current, GET /organizations/{org_id}/users \u2014 create and read tenant info and membership lists.\n- Teams: POST /teams, POST /teams/{team_id}/members/{user_id} \u2014 team creation and membership management (Admin only via dependency).\n- Items (tasks): POST /items, GET /items/{item_id}, GET /items (filters: team_id/status/priority/assigned_to/skip/limit), PUT /items/{item_id}, DELETE /items/{item_id} \u2014 core task lifecycle, with text-based search removed from the service layer, leaving the remaining filters to map to SQLAlchemy queries.\n- Comments: POST /comments, GET /items/{item_id}/comments \u2014 commenting on items.\n- Tags: POST /tags, GET /tags \u2014 tagging support.\n- API Keys & Webhooks: Admin-only endpoints for managing API keys (/api-keys) and webhooks (/webhooks).\n- Activity & Analytics: GET /activity, GET /analytics/items, GET /analytics/usage \u2014 auditing and operational analytics.\n- Notifications: POST /notifications/due-reminders, POST /notifications/overdue \u2014 admin-only reminder/alert dispatch via notification_service.\n- Exports: GET /export/items/csv, GET /export/items/json, GET /export/activity-log/csv \u2014 user/org-aware exports returning CSV/JSON responses with appropriate Content-Disposition headers.\n- Reports: GET /reports/team/{team_id}, GET /reports/user/{user_id}, GET /reports/organization \u2014 team/user/org reports with RBAC enforced (admins required for org report; user report restricted to owner unless admin).\n\nImportant behaviors:\n- Response models: Endpoints return Pydantic schemas (app/schemas.py) for consistent request/response shapes and validation, while export endpoints stream CSV/JSON payloads via Response.\n- Auth & RBAC: Endpoints declare dependencies to enforce JWT-based authentication and role checks (require_role) or API key verification, including admin-only notification/export/report routes.\n- Pagination & filtering: list endpoints support skip/limit and the supported typed filters that map to SQLAlchemy queries in services (team/status/priority/assigned_to only, without the prior title/description text search); export/report filters reuse the same criteria when applicable.\n- Status codes: create operations use 201, deletes use 204, and routes raise HTTPException with appropriate codes on not-found/forbidden/unauthorized.\n\nmain.py highlights:\n- Mounts router at /api/v1, creates DB tables at startup (Base.metadata.create_all), and configures middleware:\n  - CORS (allow_origins=[\"*\"] by default; production should restrict origins)\n  - Request timing middleware that adds X-Process-Time header and logs request method/path/status/time\n  - Global exception handler returning 500 with structured logging",
    "source_files": [
      "app/routes.py",
      "main.py",
      "app/services.py",
      "app/schemas.py",
      "app/dependencies.py"
    ]
  },
  {
    "text": "# Authentication & Authorization\n\nSecurity primitives are implemented across app/auth.py and app/dependencies.py to support password-based login, JWT access tokens, API keys, and role-based authorization.\n\nAuth primitives (app/auth.py):\n- Password hashing & verification: passlib CryptContext with bcrypt scheme (get_password_hash, verify_password).\n- JWT tokens: create_access_token and decode_access_token using python-jose with HS256. SECRET_KEY is generated in code for dev (secrets.token_urlsafe) \u2014 production must source this from a secure environment variable.\n- API key generation: generate_api_key produces sk_-prefixed secrets using secrets.token_urlsafe.\n\nDependency layer (app/dependencies.py):\n- HTTPBearer-based token reading: get_current_user decodes JWT, fetches user by id (payload[\"sub\"]), ensures active user, updates last_login timestamp.\n- get_current_active_user / get_current_organization: thin wrappers that enforce active user and active tenant checks.\n- require_role(required_role): factory that enforces role hierarchy (viewer < member < admin < owner) for Admin/Owner-only endpoints.\n- verify_api_key: header-based X-API-KEY check that looks up active APIKey, checks expiration, updates last_used_at and returns organization context.\n\nSecurity notes:\n- Token expiry is set to 24 hours in code (ACCESS_TOKEN_EXPIRE_MINUTES constant) but is configurable if replaced by env-based settings.\n- Secrets in the code are placeholders; immediate change is required before production (use .env and secrets manager).\n- RBAC is enforced at route-level through dependencies rather than inline checks; this yields composable, testable authorization logic.\n",
    "source_files": [
      "app/auth.py",
      "app/dependencies.py",
      "app/models.py"
    ]
  },
  {
    "text": "# Pydantic Schemas (API Contracts)\n\napp/schemas.py contains the request and response models used throughout the API. These Pydantic models define validation, defaulting, and serialization for the HTTP surface.\n\nKey characteristics:\n- Pattern: Base -> Create/Update -> Read for most domain entities (Organization, User, Team, Tag, Item, Comment, APIKey, Webhook).\n- orm_mode enabled on Read models so SQLAlchemy ORM instances can be returned directly from routes and serialized into JSON.\n- Typed fields and default values: Enums from app.models are reused (ItemStatus, PriorityLevel, UserRole, SubscriptionTier) to maintain alignment between API and DB layers.\n- Compound & nested shapes: ItemRead contains nested lists of assignees (List[UserRead]) and tags (List[TagRead]) to represent relationships.\n- Analytics shapes: ItemAnalytics and UsageAnalytics provide aggregated response schemas for operational endpoints.\n\nWhy it matters:\nThese schemas are the explicit API contract; changes here impact backwards compatibility, clients, and documentation (auto-generated via FastAPI docs). They also centralize validations like email formats and datetime typing.\n",
    "source_files": [
      "app/schemas.py"
    ]
  },
  {
    "text": "# Database Engine, Sessions & Lifecycle\n\napp/database.py provides the SQLAlchemy engine, SessionLocal factory, and Base declarative class used across the application.\n\nContents & usage:\n- Engine: create_engine configured for SQLite by default (sqlite:///./test.db) with connect_args={\"check_same_thread\": False} to allow multi-threaded access in dev server. Production should replace this URL with a managed RDBMS (Postgres) and use connection pooling settings.\n- SessionLocal: sessionmaker(autocommit=False, autoflush=False, bind=engine) returning scoped Session instances used by get_db dependency.\n- Base: declarative_base used by app/models.py for ORM class definitions.\n- get_db dependency: yields a session per request and ensures closure in a finally block \u2014 used widely in route dependencies and services.\n\nOperational notes & gaps:\n- No migrations: The project calls Base.metadata.create_all(bind=engine) in main.py to create tables at startup \u2014 fine for early development but migrations (Alembic) are required for production schema evolution.\n- Indexes: models define index=True on common lookups but larger scale requires explicit index planning and query profiling.\n- Backups & restore: not implemented inside code; docs/deployment.md references backup strategies. For production, point DB to external service and backup snapshots.\n",
    "source_files": [
      "app/database.py",
      "app/models.py",
      "main.py",
      "docs/deployment.md"
    ]
  },
  {
    "text": "# Application Entrypoint, Middleware & Observability\n\nmain.py is the FastAPI application bootstrap that configures middleware, logging, global exception handling, DB creation and mounts the API router.\n\nMiddleware & behaviors:\n- CORS: CORSMiddleware is configured with allow_origins=[\"*\"] (placeholder) \u2014 update to explicit origins in production.\n- Request timing: a custom middleware wraps each request to record processing time (ms), logs method/path/status/time and injects X-Process-Time header into responses.\n- Global exception handler: catches unhandled exceptions, logs stack traces, and returns a 500 JSON response.\n- Auto schema/docs: FastAPI docs available at /docs and /redoc per app config.\n- Item listing now relies solely on the various status/priority/assignee filters; the optional search_text query parameter and corresponding case-insensitive title/description filtering have been removed.\n- Admin utilities: new notification routes use notification_service to dispatch due date reminders and overdue alerts, while export/report routes powered by export_service stream CSV/JSON payloads and organization/team/user reports with role-based access checks and timestamped Content-Disposition headers.\n\nOperational observability & logging:\n- Uses Python logging with INFO level; request middleware logs each request. Services and handlers also raise HTTPException with clear status codes which surface to clients. The new export/report and notification handlers follow the same logging/exception pattern, and the code contains TODOs to persist request-level metrics to the DB (log_usage) where the org_id extraction would be required from the auth token.\n\nStartup behavior:\n- Calls Base.metadata.create_all(bind=engine) to ensure DB tables exist at service start.\n- Includes root and /health endpoints for basic readiness/liveness checks.",
    "source_files": [
      "main.py",
      "app/routes.py",
      "app/services.py"
    ]
  },
  {
    "text": "# Infrastructure & Deployment Notes\n\nThe repository contains Docker and deployment artifacts and supporting docs to run the application in development and production.\n\nKey files & responsibilities:\n- docker-compose.yml: orchestration for PostgreSQL (production or dev), application, and Nginx reverse proxy. Configures volumes, health checks, environment variables, ports, and restart policies.\n- Dockerfile: builds a Python 3.11-slim based image (installs system deps, Python deps, copies source, runs uvicorn). Use for containerized deployment.\n- .env.example: template for environment variables (DB URL, SECRET_KEY, CORS, rate limiting, upload paths, logging). Important to fill for production and not keep secrets in source.\n- docs/deployment.md & docs/feature-comparison.md: provide production deployment guidance \u2014 SSL termination, scaling notes, monitoring, backups, migrations, and security hardening recommendations.\n\nProduction considerations:\n- Replace SQLite with managed Postgres & add Alembic migrations (no migrations implemented currently).\n- Move SECRET_KEY and other secrets to environment / secret manager; do not use runtime-generated secrets in production.\n- Configure CORS, rate limits, and RBAC defaults appropriately; enable request/usage logging into UsageLog for billing/analytics.\n- Add CI pipeline to build images, run tests, run migrations, and push artifacts. Add monitoring/alerting (Prometheus/Grafana, centralized logs) per docs.\n",
    "source_files": [
      "docker-compose.yml",
      "Dockerfile",
      ".env.example",
      "docs/deployment.md",
      "README.md"
    ]
  },
  {
    "text": "# Notification Service\n\napp/notifications.py provides NotificationService helpers used by export/report/alert routes to keep users informed about assignments, comments, status changes, and upcoming due dates.\n\nHighlights:\n- send_email logs (placeholder for SMTP) and supports plain/text + optional HTML bodies while capturing failures.\n- notify_item_assigned, notify_comment_added, and notify_status_changed build contextual subjects/bodies for assignees and honor HTML formatting.\n- send_due_date_reminders queries Org items due in a given window, filters out completed work, and attempts to notify assignees while returning summary stats (total items, notifications, successes).\n",
    "source_files": [
      "app/notifications.py"
    ]
  },
  {
    "text": "# Export Service & Reports\n\napp/export.py implements the ExportService used by API export/report endpoints to stream data across CSV, JSON, and report payloads.\n\nHighlights:\n- export_items_to_csv and export_items_to_json reuse get_items, serialize item metadata plus assignees/tags, optionally include comments, and surface timestamps or nested creator info.\n- generate_team_report and generate_user_report aggregate status/priority breakdowns, workload, completion rates, and recent ActivityLog entries for team/user contextual summaries, returning errors when targets are missing.\n",
    "source_files": [
      "app/export.py"
    ]
  }
]